// @ts-ignore
import * as pdfjs from "pdfjs-dist/build/pdf.min.mjs";

// @ts-ignore
await import("pdfjs-dist/build/pdf.worker.min.mjs");

export async function POST(request: Request) {
  const formData = await request.formData();
  const file = formData.getAll("file")[0] as File;
  const arrayBuffer = await file.arrayBuffer();
  const buffer = new Uint8Array(arrayBuffer);
  const pdfText = await readPdfText(buffer);

  const modelReqBody = {
    stream: false,
    params: {
      pdfText,
    },
  };

  const modelResponse = await fetch(
    `https://${process.env.MIXLAYER_APP_HOST}`,
    {
      method: "POST",
      body: JSON.stringify(modelReqBody),
      headers: {
        Authorization: `Bearer ${process.env.MIXLAYER_APP_TOKEN}`,
        "Content-Type": "application/json",
      },
    }
  );

  if (!modelResponse.ok) {
    return Response.json({ error: "model fetch failed" }, { status: 500 });
  }

  if (modelResponse.body === null) {
    console.error("Model response body is null");
    return;
  }

  // @ts-ignore
  return new Response(modelResponse.body, {
    status: 200,
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
    },
  });
}

async function readPdfText(buffer: Uint8Array): Promise<string> {
  const document = await pdfjs.getDocument({ data: buffer }).promise;
  const pageCount = document.numPages;
  const pages = [];

  for (let i = 0; i < pageCount; i++) {
    const page = await document.getPage(i + 1);
    pages.push(await parsePage(page));
  }

  let pdfText = combinePagesIntoSingleString(pages);

  return pdfText;
}

export function combinePagesIntoSingleString(pages: PdfPage[]): string {
  return pages
    .map((page) => page.lines)
    .flat()
    .join("\n");
}

/** Parse a single PDF page. */
export async function parsePage(pdfPage: pdfjs.PDFPageProxy): Promise<PdfPage> {
  const rawContent = await pdfPage.getTextContent();
  return parsePageItems(
    rawContent.items.filter(
      (item: any): item is pdfjs.TextItem => "str" in item
    )
  );
}

/**
 * Parses individual text items generated by pdf.js This allows lower level control of what actually
 * gets parsed. For example, a consumer of this function may remove entire sections of the pdf text
 * prior to passing items in here. See parsePage function above for example usage.
 *
 * @param pdfItems An array of TextItem items.
 */
export function parsePageItems(pdfItems: pdfjs.TextItem[]): PdfPage {
  const lineData: { [y: number]: pdfjs.TextItem[] } = {};

  for (let i = 0; i < pdfItems.length; i++) {
    const item = pdfItems[i];
    const y = item?.transform[5];
    if (!lineData.hasOwnProperty(y)) {
      lineData[y] = [];
    }
    // how how to intentionally test this
    /* istanbul ignore next */
    if (item) {
      lineData[y]?.push(item);
    }
  }

  const yCoords = Object.keys(lineData)
    .map((key) => Number(key))
    // b - a here because the bottom is y = 0 so we want that to be last
    .sort((a, b) => b - a)
    // insert an empty line between any 2 lines where their distance is greater than the upper line's height
    .reduce((accum: number[], currentY, index, array) => {
      const nextY = array[index + 1];
      if (nextY != undefined) {
        const currentLine = lineData[currentY]!;
        const currentLineHeight: number = currentLine.reduce(
          (finalValue, current) =>
            finalValue > current.height ? finalValue : current.height,
          -1
        );

        // currentY - nextY because currentY will be higher than nextY
        if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
          const newY = currentY - currentLineHeight;
          lineData[newY] = [];
          return accum.concat(currentY, newY);
        }
      }
      return accum.concat(currentY);
    }, []);

  const lines: string[] = [];
  for (let i = 0; i < yCoords.length; i++) {
    const y = yCoords[i];
    // idk how to actually test this
    /* istanbul ignore next */
    if (y == undefined) {
      continue;
    }
    // sort by x position (position in line)
    const lineItems = lineData[y]!.sort(
      (a, b) => a.transform[4] - b.transform[4]
    ).filter((item) => !!item.str);
    const firstLineItem = lineItems[0]!;
    let line = lineItems.length ? firstLineItem.str : "";
    for (let j = 1; j < lineItems.length; j++) {
      const item = lineItems[j]!;
      const lastItem = lineItems[j - 1]!;
      const xDiff =
        item.transform[4] - (lastItem.transform[4] + lastItem.width);

      // insert spaces for items that are far apart horizontally
      // idk how to trigger this
      /* istanbul ignore next */
      if (
        item.height !== 0 &&
        lastItem.height !== 0 &&
        (xDiff > item.height || xDiff > lastItem.height)
      ) {
        const spaceCountA = Math.ceil(xDiff / item.height);
        let spaceCount = spaceCountA;
        if (lastItem.height !== item.height) {
          const spaceCountB = Math.ceil(xDiff / lastItem.height);
          spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB;
        }
        line += Array(spaceCount).fill("").join(" ");
      }
      line += item.str;
    }
    lines.push(line);
  }

  return {
    lines,
  };
}

/** A single page within a PDF file. */
export type PdfPage = {
  lines: string[];
};
